{"categories":[{"title":"Syntax","uri":"https://zhoujb22.github.io/categories/syntax/"},{"title":"Themes","uri":"https://zhoujb22.github.io/categories/themes/"}],"posts":[{"content":"前言 上一节中，我们使用Dijkstra算法来获取最小生成树中，计算某个节点到其他所有节点的最短距离和。值得注意的是，我们必须先使用第一节中的prim算法或者其他近似的算法才能来进一步应用Dijkstra算法计算距离和。即我们不能直接使用edge中所有节点之间的距离构造的包含非树边的图去应用Dijkstra算法。\n我们用下面这幅最小生成树图进行Dijkstra算法的推演：\n包含非树边的图应用Dijkstra算法计算距离和 此处“包含非树边的图”指代上图中绿色与黑色线条权重同时存在的情况。\n选取起始点D，Dijkstra算法第一步会更新D距离A/B/E/F点的距离到distances字典当中。 接下来推出与D最近的点A，遍历A的邻居：首先排除回到D的可能；对于A的邻居B，距离为7，distance = current_distance + neighbor_distance = 5 + 7，由于12\u0026gt;9，所以distance字典中的值不会被更新； …… 可以发现，如果包含非树边，Dijkstra 算法并没有严格沿着最小生成树路径走，而是选择了不属于最小生成树的路径。直接使用包含所有节点对间距离的完整图作为输入，Dijkstra 算法会尝试找到所有最短路径，但不保证路径仅沿最小生成树。因此，需先生成最小生成树或移除非树边，才能确保计算的路径和基于最小生成树。\n小结：Dijkstra 算法属于单源路径搜索（Single-Source Shortest Path, SSSP），指的是从一个指定的起点节点（称为“源节点”）出发，计算到图中其他所有节点的最短路径的过程。Dijkstra 算法专门用于在权重非负的有向图或无向图中，计算从源节点到所有可达节点的最短路径。\n关于本节 最小生成树已经确保了所有节点之间的连接路径权重最小，且没有任何冗余边，因此在最小生成树上从任意节点出发到其他节点的最短路径就是其唯一的路径。\n本节当中，我们会引入一种在最小生成树图背景下，相比Dijkstra 算法更高效的算法，广度优先搜索BFS的变种算法。\nBFS from collections import defaultdict, deque import random def calculate_distances_from_node(adjacency_list, start_node): \u0026quot;\u0026quot;\u0026quot; 计算从选定节点到所有其他节点的最短路径和 :param adjacency_list: 邻接表 :param start_node: 选定的节点 :return: 从该节点到所有节点的距离总和 \u0026quot;\u0026quot;\u0026quot; total_distance = 0 visited = set() queue = deque([(start_node, 0)]) # 队列存储 (当前节点, 到该节点的距离) while queue: current_node, current_distance = queue.popleft() if current_node not in visited: visited.add(current_node) total_distance += current_distance # 遍历相邻节点 for neighbor, weight in adjacency_list[current_node]: if neighbor not in visited: queue.append((neighbor, current_distance + weight)) return total_distance # 计算从选定节点到所有节点的最短距离和 shortest_path_sum = calculate_distances_from_node(adjacency_list, selected_node) print(f\u0026quot;随机选定节点: {selected_node}\u0026quot;) print(f\u0026quot;从该节点到所有节点的最短距离和: {shortest_path_sum}\u0026quot;) 分析 calculate_distances_from_node 的步骤 初始化：初始化 total_distance 为0，并创建一个集合 visited 来记录已访问的节点。用双端队列 queue 存储起始节点和初始距离（0）。\n广度优先遍历：每次从 queue 中取出一个节点 current_node，若该节点未访问，则标记为已访问并将 current_distance 加入 total_distance。\n更新相邻节点：遍历当前节点 current_node 的所有邻接节点 neighbor，若邻接节点未访问，则将其加入 queue，并累加距离 weight。\n结果：最终返回从 start_node 到所有节点的距离和 total_distance。\n特点 广度优先搜索（BFS）是一种层次遍历算法，它按照层次逐层访问图中的节点。这意味着 BFS 首先访问起始节点，然后访问所有与起始节点相邻的节点，再访问这些邻居的邻居，以此类推。该方法没有使用优先队列，所以距离更新不是按照最小路径进行扩展。 遍历方式类似于广度优先搜索，但在带权重的图上，该方法未必能找到真实的最短路径和，仅适用于无权图或权重较小且结构较简单的图。 若图有负权边或不规则权重分布，BFS 会计算非最优路径和，因此该算法适用范围有限。 Dijkstra与BFS比较 函数 使用算法 适用图类型 是否找到最短路径和 时间复杂度 dijkstra Dijkstra 算法 任意带非负权边的图 是 $(O((V + E) \\log V))$ calculate_distances_from_node 广度优先搜索（变种） 无权图或简单权重图 不一定 $(O(V + E))$ 适用范围 Dijkstra 算法（dijkstra 函数）适用于带权边，能找到最短路径和，推荐用于一般的最短路径问题。 广度优先搜索法（calculate_distances_from_node 函数）更适合无权图。对于加权图，这种方法不保证找到最短路径和。 算法复杂度分析 Dijkstra 算法：\nDijkstra 算法在普通图中的时间复杂度为 $(O(E \\log V))$，其中 E 是边数，V 是节点数。 Dijkstra 使用优先队列来获取当前最短距离节点，适合有权图的最短路径计算。 在最小生成树中，虽然边数减少为 (V - 1)，但它仍然需要管理优先队列来获取最短路径，导致一定的额外操作。 BFS 方式 (calculate_distances_from_node)：\n在无环的树结构中，BFS 的时间复杂度为 $(O(V + E))$。 对于最小生成树来说，边数是 (V - 1)，所以其复杂度约为 (O(V))。 由于最小生成树中每两个节点间有唯一路径，BFS 不需要更新距离，直接沿路径遍历即可获得最短路径。 效率对比 优先队列管理开销：Dijkstra 需要维护一个优先队列，即使在最小生成树这种特殊结构中也要通过堆操作来管理节点距离。而 calculate_distances_from_node 仅需简单的队列，开销更低。 适用性：在无环的树结构中，BFS 能简单快速地遍历所有节点，因此在最小生成树上 calculate_distances_from_node 更适合，速度更快。 总结 在最小生成树这个特殊的情境下，我们已经有了最小权重形成的树，因此使用BFS进行一层一层的距离计算，最终会得到节点距离其他所有的节点的最小的距离和。此时calculate_distances_from_node 会比 Dijkstra 算法更高效，因为 BFS 的复杂度较低且无额外的优先队列开销，因此能更快计算出从起点到所有节点的最短路径和。\n","id":0,"section":"posts","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e上一节中，我们使用\u003ccode\u003eDijkstra\u003c/code\u003e算法来获取最小生成树中，计算某个节点到其他所有节点的最短距离和。值得注意的是，我们必须先使用第一节中的\u003ccode\u003eprim\u003c/code\u003e算法或者其他近似的算法才能来进一步应用\u003ccode\u003eDijkstra\u003c/code\u003e算法计算距离和。即我们不能直接使用\u003ccode\u003eedge\u003c/code\u003e中所有节点之间的距离构造的包含非树边的图去应用\u003ccode\u003eDijkstra\u003c/code\u003e算法。\u003c/p\u003e","tags":["Quant Knowledge","Algorithms"],"title":"Minimum spanning tree 3","uri":"https://zhoujb22.github.io/2024/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95-3/","year":"2024"},{"content":"引言 前一部分中，我们了解到了可以使用prim来构建最小生成树，为了刻画节点在整个树中是否处于中心位置，有许多衡量这一位置的指标，但本文中我们可以采用测量某一节点到所有其他节点的沿最小生成树路径的总距离。本文引入算法来实现高效计算这一距离（实际上是接近中心度的中间过程）。\n1、度中心度 节点度中心度，计算方法为节点的连接的边的数量除以可能的最大连接数，对于 n 个节点的网络，最大连接数为 n-1，即：\n$$𝑑_𝑣 = deg(v)⁄𝑚$$\n其中 deg 为节点 v 的连接边数量，m 为最大连接数（n-1）。\n2、接近中心度 接近中心度衡量了节点与其他节点的距离，计算方法为加总节点到其他所有节点的最短距离，接近中心度也通过最大连接距离进行归一化，即：\n$$𝑐_𝑣 = （n − 1)⁄𝑑$$\n其中 d 为节点与其他节点连接距离的加总。\n3、中介中心度 中介中心度衡量了，节点位于其他节点的最短路径上的程度，即：\n$$b_v = \\sum_{s,t} \\frac{\\sigma(s,t|v)}{\\sigma(s,t)}$$\n𝜎(𝑠,𝑡)为节点 s，t 的最短路径的数量，𝜎(𝑠,𝑡|𝑣)为 s 和 t 最短路径经过节点 v 的数量。\n\u0026ndash;来源：《股票网络中心度因子异象研究\u0026ndash;by华创证券》\n示例：\n假设存在最小生成树: (7, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;)，(5, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;D\u0026rsquo;)， (8, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;C\u0026rsquo;) 对于A，距离和为7+5+8=20; 对于B，距离和为B到A、C、D的距离和，为7+(7+5)+(7+8)=34; 对于C，距离和为C到A、B、D的距离和，为8+(8+5)+(8+7)=36； 观察可以发现，在该树中，A处于中心位置，其到所有其他节点的沿最小生成树路径的总距离最小，而边缘位置的节点，该数值越大；想象节点为单支股票，衡量股票是否处于同类股票的中心位置，有助于确定股票在同一行业中的“重要程度”。\n为Dijkstra算法构建graph # 构建图的邻接表 def build_graph(result): graph = defaultdict(list) for distance, node1, node2 in result: graph[node1].append((distance, node2)) graph[node2].append((distance, node1)) return graph Dijkstra算法: 计算某个节点到其他所有节点的最短距离和 # Dijkstra算法,计算某个节点到其他所有节点的最短距离和 def dijkstra(graph, start): # 初始化距离字典 distances = {node: float(\u0026quot;inf\u0026quot;) for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # 如果从队列取出的距离大于当前节点已知的最短距离,则跳过 if current_distance \u0026gt; distances[current_node]: continue # 更新相邻节点的最短距离 for neighbor_distance, neighbor in graph[current_node]: distance = current_distance + neighbor_distance if distance \u0026lt; distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # 返回从起点到所有其他节点的距离和 return sum(distances.values()) 注：\n在 Python 中，当你对字典（dict）直接使用 for 循环时，for node in graph 会遍历字典的键（keys）。换句话说，node 代表的是字典中每个键的值，而不是字典的值（values）。 在 Python 中，空列表 [] 被视为 False。在循环条件中，只有当条件为 True 时，循环才会执行。 算法原理 Dijkstra算法，用于计算从起点 start 到图 graph 中所有其他节点的最短路径。具体工作流程如下：\n初始化:\n定义一个字典 distances 来存储从起点 start 到每个节点的最短距离。初始化时，起点到自己的距离为 0，其余所有节点的距离设为无穷大（float(\u0026quot;inf\u0026quot;)）。 使用优先队列 priority_queue（小顶堆），将起点 start 放入队列，优先级为 0，表示当前已知的距离。 处理队列中的节点：\n第一轮，通过 heapq.heappop 从优先队列中取出具有最小距离的节点 current_node 和对应的距离 current_distance。此时取出来的节点是start，由于0=0，所以不跳过下一回合； 对于graph中start的节点，遍历与start有距离数据的节点，这些新节点与start的距离是0+neighbor_distance，由于distances[neighbor]在第一轮必定是无穷大的，更新该节点在distance字典中的值，并将(distance, neighbor)压入最小堆priority_queue中。 后续循环过程中，由于if distance \u0026lt; distances[neighbor]使得新节点的搜寻不能走回头路，因为distance = current_distance + neighbor_distance使得如果走回头路，distance一定会大于在distances中储存的上一轮的数据。 重复步骤：\n继续从优先队列中取出下一个距离最小的节点，更新其邻居的最短距离，直到优先队列为空。 返回结果：\n最终，算法返回从起点到所有其他节点的最短路径和 sum(distances.values())。 时间复杂度 该算法使用优先队列来选择最小距离的节点，单次操作的时间复杂度为 ( O(\\log V) )，其中 ( V ) 是节点的数量。对于每条边的松弛操作，时间复杂度是 ( O(E) )，因此总的时间复杂度为 ( O((V + E) \\log V) )。 适用场景 Dijkstra 算法通常用于加权图中找出单源最短路径，图的边权重必须为非负数。 并行执行算法 # 计算每个节点的最短距离和,支持并行化 def compute_all_shortest_path_sums(graph, n_jobs=4): node_sums = Parallel(n_jobs=n_jobs)(delayed(dijkstra)(graph, node) for node in graph) # 构建字典,将结果和节点对应起来 return {node: node_sum for node, node_sum in zip(graph, node_sums)} 并行操作的理解： Parallel 的性质：\nParallel 是 joblib 库中的并行执行器，确保了任务的结果顺序与输入顺序相同，即使任务是并行执行的。在任务分配给多个工作线程后，Parallel 会根据输入顺序收集这些任务的输出结果，然后按照这个顺序将结果返回。\n因此使用zip(graph, node_sums)不会影响key与距离的匹配。\n换句话说，不管某个任务完成得早还是晚，Parallel 都会按提交任务时的顺序对输出结果进行排序。\ndelayed 的作用：\ndelayed 只是用来延迟计算的包装器，主要是将函数调用（如 dijkstra(graph, node)） 转换为一个可传递给并行执行的任务对象。它的作用是封装这些函数以便传递给 Parallel。\n然而，delayed 并不会决定任务返回结果的顺序，结果顺序的维护完全是 Parallel 内部实现的。\n","id":1,"section":"posts","summary":"\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003e前一部分中，我们了解到了可以使用prim来构建最小生成树，为了刻画节点在整个树中是否处于中心位置，有许多衡量这一位置的指标，但本文中我们可以采用测量某一节点到所有其他节点的沿最小生成树路径的总距离。本文引入算法来实现高效计算这一距离（实际上是接近中心度的中间过程）。\u003c/p\u003e","tags":["Quant Knowledge","Algorithms"],"title":"Minimum spanning tree 2","uri":"https://zhoujb22.github.io/2024/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95-2/","year":"2024"},{"content":"常见的基于股价变化构建网络的方式 Mantegna 最早将复杂网络研究方法引入股票市场，Barabasi 在 2003 年的研究中证实美国股票市场满足无标度网络性质。在国内股票市场的研究中，Huang 在 2009 年的研究中证实沪深 1080 只股票满足幂律分布，Mai 在 2014年的复杂网络系统研究表明沪深 300 的核心行业为工业，谢凌峰和陈志 2016 年的研究中表明在沪港通开通后网络的平均度和聚类系数都有了显著的上升。\n在上述的研究中，构建网络的方法大致可以分为三类，第一类是类似牛晓健（2021）的做法，采用阈值截断法(Threshold Truncation Method，TTM)构建网络；第二类是类似于Huang（2009）的做法，采用平面最大过滤图法(Planar Maximally Filtered Graph，PMFG)构建网络；第三类是类似于谢赤（2021）的做法利用最小生成树(Minimum Spanning Tree，MST)法构建网络。\n最小生成树法对网络信息的过滤最为严格，只提取网络中各节点间相关性最大的主要信息；平面最大过滤图方法最大限度上保留了网络中与有效信息相关的连边，但有效信息分析相对复杂、网络计算速度相对较慢；阈值截断法基于不同阈值构建的网络结构差异较大。\n\u0026ndash;来源：《股票网络中心度因子异象研究\u0026ndash;by华创证券》\n通过prim算法构建最小生成树 from collections import defaultdict from heapq import * def prim(start, edges): \u0026quot;\u0026quot;\u0026quot; 用于根据所有节点之间的距离,然后生成最小生成树 :param start: 初始节点选择；此节点可以随机化，但将导致多次使用函数结果不唯一； :param edges: 股票列表产生的距离数据，形式为(7, 'A', 'B')，tuple的第一个元素表示距离，第二、三个元素表示节点的名称，此处要求不能同时存在(7, 'A', 'B')与(7, 'B', 'A')。 :return: 构建最小生成树的距离数据 \u0026quot;\u0026quot;\u0026quot; adjacent_dict = defaultdict(list) # 注意:defaultdict(list)必须以list做为变量 # 将(7, 'A', 'B')分别在A/B的key对应值的list中记录，保持新增元组的第二个元素与key相同。 for weight, v1, v2 in edges: adjacent_dict[v1].append((weight, v1, v2)) adjacent_dict[v2].append((weight, v2, v1)) \u0026quot;\u0026quot;\u0026quot; 经过上述操作,将图转化为以下邻接表形式: {'A': [(7, 'A', 'B'), (5, 'A', 'D')], 'C': [(8, 'C', 'B'), (5, 'C', 'E')], 'B': [(7, 'B', 'A'), (8, 'B', 'C'), (9, 'B', 'D'), (7, 'B', 'E')], 'E': [(7, 'E', 'B'), (5, 'E', 'C'), (15, 'E', 'D'), (8, 'E', 'F'), (9, 'E', 'G')], 'D': [(5, 'D', 'A'), (9, 'D', 'B'), (15, 'D', 'E'), (6, 'D', 'F')], 'G': [(9, 'G', 'E'), (11, 'G', 'F')], 'F': [(6, 'F', 'D'), (8, 'F', 'E'), (11, 'F', 'G')]}) \u0026quot;\u0026quot;\u0026quot; minu_tree = [] # 存储最小生成树结果 visited = {start} # 存储访问过的顶点,注意指定起始点 adjacent_vertexs_edges = adjacent_dict[start] heapify(adjacent_vertexs_edges) # 转化为小顶堆,便于找到权重最小的边 while adjacent_vertexs_edges: weight, v1, v2 = heappop(adjacent_vertexs_edges) # 权重最小的边,并同时从堆中删除. if v2 not in visited: visited.add(v2) # 在used中有第一选定的点'A',上面得到了距离A点最近的点'D',举例是5.将'd'追加到used中 minu_tree.append((weight, v1, v2)) # 再找与d相邻的点,如果没有在heap中,则应用heappush压入堆内,以加入排序行列 for next_edge in adjacent_dict[v2]: # 找到v2相邻的边 if next_edge[2] not in visited: # 如果v2还未被访问过,就加入堆中 heappush(adjacent_vertexs_edges, next_edge) return minu_tree prim代码解读 defaultdict:用以指定字典的value类型。prim函数中默认adjacent_dict为以list为元素的字典。在请求的key未找到时，会将新的key默认为指定的类型。prim函数中，默认指定该类型为一个空的list。这也是可以直接对value使用append method的方法。 示例：源自官方文档：Setting the default_factory to int makes the defaultdict useful for counting (like a bag or multiset in other languages): s = 'mississippi' d = defaultdict(int) for k in s: d[k] += 1 sorted(d.items()) heapq: 该模块提供了堆队列算法（也称为优先级队列算法）的实现。堆是二叉树，每个父节点的值都小于或等于其子节点的值。 堆的一个有趣特性是其最小元素始终是根。堆排序可以通过将所有值推送到堆上然后一次弹出一个最小的值来实现。 heapq中，==堆元素可以是元组。==这对于在跟踪的主记录旁边分配比较值（例如任务优先级）很有用。 prim使用heapq的原理： 选定start后，将与start存在距离的点压入小栈堆。 找到小栈堆内距离最小的组，如果与start对应的新节点没有被访问过，就标记新节点为visited，同时将这组最小距离组合放入mini_tree。 将2中相邻节点（未被标记为visited）都压入小栈堆。 此时小栈堆中有与start和2中新节点所有相邻的节点。 循环，回到1，重复上述流程，通过小栈堆找到与start或2中新节点距离最近的点，直至adjacent_vertexs_edges没有元素而停止。 堆的有趣类比： 参考锦标赛制，倘若平铺所有list中的元素，如[1, 3, 2, 6, 8, 5]，每两数选出最小数晋级，上浮结果为[1, 2, 5]；再一轮上浮结果为[1, 5]；最后一轮上浮结果为[1]。可以发现list中最小的元素始终在堆顶。 prim使用heapq的优势在于，小堆栈使得每一轮使用尽可能少的时间便能选择出距离最小的元组，让最小生成树生成的过程加速。 好的，插入新元素后，堆的“上浮”操作是为了保持堆的性质。我们以一个最小堆（min-heap）为例，来演示插入新元素后进行上浮的过程。\nheappush原理演示 [i] heappush将值项推送到堆上，保持堆不变。通过上浮操作，插入的新元素逐层与父节点比较并交换，直到找到合适的位置，最终保持了最小堆的性质。 假设我们有一个当前的最小堆： 3 / \\ 5 7 / \\ / \\ 8 10 12 15 它在数组中的表示为：\n[3, 5, 7, 8, 10, 12, 15] 现在我们要插入一个新元素 4，插入过程如下：\n步骤 1: 插入元素 首先，将元素 4 插入到堆的最后一个位置，保持堆的完全二叉树结构：\n3 / \\ 5 7 / \\ / \\ 8 10 12 15 / 4 对应的数组表示为：\n[3, 5, 7, 8, 10, 12, 15, 4] 步骤 2: 进行上浮操作 现在需要检查新插入的元素 4 是否破坏了堆的性质（即父节点的值是否仍然小于或等于子节点的值）。如果破坏了，需要进行上浮操作。\n4 的父节点是 8，而 4 \u0026lt; 8，所以需要交换 4 和 8： 3 / \\ 5 7 / \\ / \\ 4 10 12 15 / 8 对应的数组表示为：\n[3, 5, 7, 4, 10, 12, 15, 8] 步骤 3: 继续上浮 现在，4 的父节点是 5，而 4 \u0026lt; 5，所以继续交换 4 和 5：\n3 / \\ 4 7 / \\ / \\ 5 10 12 15 / 8 对应的数组表示为：\n[3, 4, 7, 5, 10, 12, 15, 8] 步骤 4: 上浮完成 此时，4 的父节点是 3，且 4 \u0026gt; 3，满足最小堆的性质，因此不需要再上浮了。 最终的堆结构为：\n3 / \\ 4 7 / \\ / \\ 5 10 12 15 / 8 对应的数组表示为：\n[3, 4, 7, 5, 10, 12, 15, 8] ","id":2,"section":"posts","summary":"\u003ch2 id=\"常见的基于股价变化构建网络的方式\"\u003e常见的基于股价变化构建网络的方式\u003c/h2\u003e\n\u003cp\u003eMantegna 最早将复杂网络研究方法引入股票市场，Barabasi 在 2003 年的研究中证实美国股票市场满足无标度网络性质。在国内股票市场的研究中，Huang 在 2009 年的研究中证实沪深 1080 只股票满足幂律分布，Mai 在 2014年的复杂网络系统研究表明沪深 300 的核心行业为工业，谢凌峰和陈志 2016 年的研究中表明在沪港通开通后网络的平均度和聚类系数都有了显著的上升。\u003c/p\u003e","tags":["Quant Knowledge","Algorithms"],"title":"Minimum spanning tree 1","uri":"https://zhoujb22.github.io/2024/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95-1/","year":"2024"},{"content":"连接数据库 /c database_name pqsl -h -p -U name 创建数据库 CREATE DATABASE # 非常危险的命令行 DROP DATABASE 创建table CREATE TABLE name ( Column_name data_name constraints if any ); 查看创建表格的基本信息 插入/选择数据： 查看Table内容 表格排序、取unique值、匹配符合条件、布尔值 展示有限行 模式匹配、分组、函数、筛选 最大、最小、平均、近似函数 处理空值（NULL） 避免计算错误 时间处理 删除限制条件 删除表格行、增加限制条件 ALTER TABLE person DROP CONSTRAINT unique_email_address UNIQUE(email); \\d person ALTER TABLE person ADD UNIQUE(email); \\d person DELETE FROM person; 更新Table数据 处理primary key冲突 INSERT INTO person () VALUES () ON CONFLICT (列名) DO NOTHING; # conflict on unique column. INSERT INTO person () VALUES () ON CONFLICT (列名) DO UPDATING SET A=a, B=b; Inner Joins 只保留有交集的部分 Left Joins 保留左侧和交集部分 Delete foreign keys UUID in action CREATE TABLE car1 ( car_uid UUID NOT NULL PRIMARY KEY, make VARCHAR(50) NOT NULL, price NUMERIC(19,2) NOT NULL CHECK (price\u0026gt;0)); INSERT INTO car1 (car_uid, make , price) VALUES (uuid_generate_v4(), 'Benz', '10000.00'); SELECT * FROM person JOIN car USING(car_uid); // 相同列 Output CSV ","id":3,"section":"posts","summary":"\u003ch2 id=\"连接数据库\"\u003e连接数据库\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-psql\"\u003e/c database_name\n\npqsl -h -p -U name\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"创建数据库\"\u003e创建数据库\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-psql\"\u003eCREATE DATABASE\n# 非常危险的命令行\nDROP DATABASE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"创建table\"\u003e创建table\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-psql\"\u003eCREATE TABLE name (\nColumn_name data_name constraints if any\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"查看创建表格的基本信息\"\u003e查看创建表格的基本信息\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/3797c539861dd528a6fa10864e53d0c9.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"插入选择数据\"\u003e插入/选择数据：\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/f84ce471ff4b67fc8ad46e566b178ae4.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"查看table内容\"\u003e查看Table内容\u003c/h2\u003e\n\u003ch2 id=\"表格排序取unique值匹配符合条件布尔值\"\u003e表格排序、取unique值、匹配符合条件、布尔值\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/78a8e32d04816f2b863c9099b1f35898.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"展示有限行\"\u003e展示有限行\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/6e74de7df3a28282f0b03056850b6b11.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"模式匹配分组函数筛选\"\u003e模式匹配、分组、函数、筛选\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/5acaceecea3dcedb9901b4999a19b8e3.png\" alt=\"\"\u003e\n\u003cimg src=\"/images/3823fac4613ae67ac27adfc0d07d3355.png\" alt=\"\"\u003e\n\u003cimg src=\"/images/639b1b2d6041aeee41ea66340941f585.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"最大最小平均近似函数\"\u003e最大、最小、平均、近似函数\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/a0b6a0a09d2e9afa2544bd65c19ccf45.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"处理空值null\"\u003e处理空值（NULL）\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/402d1e1ac463af166c385adba0537247.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"避免计算错误\"\u003e避免计算错误\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/83a4b2f676e295af2fc8231bc807e1d5.png\" alt=\"\"\u003e\n\u003cimg src=\"/images/46a8ca2a064ff008c7eb4203de8fcd52.png\" alt=\"\"\u003e\n\u003cimg src=\"/images/d61fd44adf54d4c7cce5a892bedf8f8f.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"时间处理\"\u003e时间处理\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/f48aafde9e252a1154126f7e21f3b44b.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"删除限制条件\"\u003e删除限制条件\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/5b6a3cdf1fc95d421ceaf2e2f89bb853.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"删除表格行增加限制条件\"\u003e删除表格行、增加限制条件\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/0ca1f21d0667a8e11daa84b83c105b08.png\" alt=\"\"\u003e\n\u003cimg src=\"/images/f1e72063fc6d340b94455b27d4406f74.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eALTER TABLE person DROP CONSTRAINT unique_email_address UNIQUE(email);\n\\d person\nALTER TABLE person ADD UNIQUE(email);\n\\d person\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eDELETE FROM person;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"更新table数据\"\u003e更新Table数据\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/b5ca6835144cff670b3c34c0e1dcd401.png\" alt=\"\"\u003e\u003c/p\u003e","tags":["Quant Skills","SQL"],"title":"Database Command 1","uri":"https://zhoujb22.github.io/2024/10/database/","year":"2024"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Inline Markdown In Table italics bold strikethrough code Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Item First Sub-item Second Sub-item Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","id":4,"section":"posts","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://zhoujb22.github.io/2019/03/markdown-syntax/","year":"2019"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nInstagram Simple Shortcode View this post on Instagram YouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode ","id":5,"section":"posts","summary":"\u003cp\u003eHugo ships with several \u003ca href=\"https://gohugo.io/content-management/shortcodes/#use-hugo-s-built-in-shortcodes\"\u003eBuilt-in Shortcodes\u003c/a\u003e for rich content, along with a \u003ca href=\"https://gohugo.io/about/hugo-and-gdpr/\"\u003ePrivacy Config\u003c/a\u003e and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\u003c/p\u003e","tags":["shortcodes","privacy"],"title":"Rich Content","uri":"https://zhoujb22.github.io/2019/03/rich-content/","year":"2019"}],"tags":[{"title":"Algorithms","uri":"https://zhoujb22.github.io/tags/algorithms/"},{"title":"Css","uri":"https://zhoujb22.github.io/tags/css/"},{"title":"Html","uri":"https://zhoujb22.github.io/tags/html/"},{"title":"Index","uri":"https://zhoujb22.github.io/tags/index/"},{"title":"Markdown","uri":"https://zhoujb22.github.io/tags/markdown/"},{"title":"Privacy","uri":"https://zhoujb22.github.io/tags/privacy/"},{"title":"Quant Knowledge","uri":"https://zhoujb22.github.io/tags/quant-knowledge/"},{"title":"Quant Skills","uri":"https://zhoujb22.github.io/tags/quant-skills/"},{"title":"Shortcodes","uri":"https://zhoujb22.github.io/tags/shortcodes/"},{"title":"SQL","uri":"https://zhoujb22.github.io/tags/sql/"},{"title":"Themes","uri":"https://zhoujb22.github.io/tags/themes/"}]}